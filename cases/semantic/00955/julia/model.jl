#= 
    This code was generated by heta-compiler of v0.5.9
    
=#

module julia 
using SimSolver

### create default constants
constants_ = NamedTuple{(
  
)}(Float64[
  
])

### initialization of ODE variables and Records
function start_(cons)
    #() = cons

    # Heta initialize
    t = 0.0 # initial time
    P1 = t
    P2 = abs(t)
    P3 = abs(-t)
    P4 = acos(t)
    P5 = acos(-t)
    P6 = asin(t)
    P7 = asin(-t)
    P8 = atan(t)
    P9 = atan(-t)
    P10 = ceil(t)
    P11 = ceil(-t)
    P13 = cos(t)
    P14 = cos(-t)
    P15 = exp(t)
    P16 = exp(-t)
    P18 = floor(t)
    P19 = floor(-t)
    P20 = log(t + 1.0)
    P22 = log(10.0, t + 1.0)
    P24 = ^(t, 2.0)
    P25 = ^(2.0, t)
    P26 = ^(t, t)
    P29 = nthRoot(t, 2.0)
    P31 = sin(t)
    P32 = sin(-t)
    P34 = tan(t)
    P35 = tan(-t)
    P37 = t + 2.0
    P38 = t - 2.0
    P39 = t / 2.0
    P40 = t * 3.0
    P41 = 2.0 + t
    P42 = 2.0 - t
    P43 = 2.0 / (t + 1.0)
    P44 = 3.0 * t
    
    # save results

    return (
        [ 0.0 ], # init for fake variable
        [
        ]
    )
end

### calculate RHS of ODE
function ode_(du, u, p, t)
    cons = p.constants
    () = p.static
    () = u 

    # Heta rules
    P1 = t
    P2 = abs(t)
    P3 = abs(-t)
    P4 = acos(t)
    P5 = acos(-t)
    P6 = asin(t)
    P7 = asin(-t)
    P8 = atan(t)
    P9 = atan(-t)
    P10 = ceil(t)
    P11 = ceil(-t)
    P13 = cos(t)
    P14 = cos(-t)
    P15 = exp(t)
    P16 = exp(-t)
    P18 = floor(t)
    P19 = floor(-t)
    P20 = log(t + 1.0)
    P22 = log(10.0, t + 1.0)
    P24 = ^(t, 2.0)
    P25 = ^(2.0, t)
    P26 = ^(t, t)
    P29 = nthRoot(t, 2.0)
    P31 = sin(t)
    P32 = sin(-t)
    P34 = tan(t)
    P35 = tan(-t)
    P37 = t + 2.0
    P38 = t - 2.0
    P39 = t / 2.0
    P40 = t * 3.0
    P41 = 2.0 + t
    P42 = 2.0 - t
    P43 = 2.0 / (t + 1.0)
    P44 = 3.0 * t
    
    #p.static .= []
    du .= [ 1.0 ] # RHS for fake variable
end

### output function
function make_saving_(outputIds::Vector{Symbol})
    function saving_(u, t, integrator)
        cons = integrator.p.constants
        () = integrator.p.static
        () = u

        # Heta rules
        P1 = t
        P2 = abs(t)
        P3 = abs(-t)
        P4 = acos(t)
        P5 = acos(-t)
        P6 = asin(t)
        P7 = asin(-t)
        P8 = atan(t)
        P9 = atan(-t)
        P10 = ceil(t)
        P11 = ceil(-t)
        P13 = cos(t)
        P14 = cos(-t)
        P15 = exp(t)
        P16 = exp(-t)
        P18 = floor(t)
        P19 = floor(-t)
        P20 = log(t + 1.0)
        P22 = log(10.0, t + 1.0)
        P24 = ^(t, 2.0)
        P25 = ^(2.0, t)
        P26 = ^(t, t)
        P29 = nthRoot(t, 2.0)
        P31 = sin(t)
        P32 = sin(-t)
        P34 = tan(t)
        P35 = tan(-t)
        P37 = t + 2.0
        P38 = t - 2.0
        P39 = t / 2.0
        P40 = t * 3.0
        P41 = 2.0 + t
        P42 = 2.0 - t
        P43 = 2.0 / (t + 1.0)
        P44 = 3.0 * t
        
        # calculate amounts
        P1_ = P1
        P2_ = P2
        P3_ = P3
        P4_ = P4
        P5_ = P5
        P6_ = P6
        P7_ = P7
        P8_ = P8
        P9_ = P9
        P10_ = P10
        P11_ = P11
        P13_ = P13
        P14_ = P14
        P15_ = P15
        P16_ = P16
        P18_ = P18
        P19_ = P19
        P20_ = P20
        P22_ = P22
        P24_ = P24
        P25_ = P25
        P26_ = P26
        P29_ = P29
        P31_ = P31
        P32_ = P32
        P34_ = P34
        P35_ = P35
        P37_ = P37
        P38_ = P38
        P39_ = P39
        P40_ = P40
        P41_ = P41
        P42_ = P42
        P43_ = P43
        P44_ = P44

        d = Base.@locals
        return [d[id] for id in outputIds]
    end
end

### time events

### discrete events

### continous events

### event assignments


### OUTPUT ###

x00955 = Model(
  start_,
  ode_,
  [
  ],
  make_saving_,
  constants_
)

models = (
    x00955 = x00955
)
tasks = ()

export models, tasks

end
